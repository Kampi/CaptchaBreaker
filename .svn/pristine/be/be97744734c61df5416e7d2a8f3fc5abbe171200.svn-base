import os
import cv2
import numpy
from keras.optimizers import SGD
from keras.utils import plot_model
from keras.models import load_model
from keras.preprocessing.image import img_to_array
from sklearn.preprocessing import LabelBinarizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt
import pydot

from .Preprocessing import ImagePreprocessing
from .LeNet import LeNet
from .ErrorCodes import ErrorCodes

''' ToDo
    - Für ein geladenes Model müssen die Label noch erzeugt werden (Featurevektor speichern?)
'''

class CaptchaSolver(ErrorCodes):     

    def __init__(self, Width, Height, Depth, Epochs):
        self.Network = LeNet()
        self.TrainingData = []
        self.TrainingLabel = []
        self.TrainX = []
        self.TrainY = []
        self.TestX = []
        self.TestY = []
        self.LeNet = LeNet()
        self.Model = 0
        self.Binarizer = 0
        self.History = 0
        self.Labelcount = 0
        self.Width = Width
        self.Height = Height
        self.Depth = Depth
        self.Epochs = Epochs
        self.Batchsize = 32
        self.ImageProcessor = ImagePreprocessing(Width, Height)

    def PrintModel(self, Path):
        if(self.Model != 0):
            print("[INFO] Save visualization to " + Path + "...")
            plot_model(self.Model, to_file = Path,show_shapes = True)
        else:
            print("[ERROR] No model available!")
            return ErrorCodes.NO_MODEL

        return ErrorCodes.NO_ERROR

    def Plot(self):
        # Cancel if no training history is available
        if(not(self.History == 0)):
            # Create a new plot
            plt.style.use("ggplot")
            plt.figure(num = "Training")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["loss"], label = "Train (Loss)")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["val_loss"], label = "Test (Loss)")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["acc"], label = "Accuracy")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["val_acc"], label = "Test (Accuracy)")
            plt.title("Loss and Accuracy")
            plt.xlabel("Epoch #")
            plt.ylabel("Loss/Accuracy")
            plt.legend()
            plt.show()
        else:
            print("[ERROR] No history available!")
            return ErrorCodes.NO_MODEL
        
        return ErrorCodes.NO_ERROR

    def LoadModel(self, Path):
        # Check if path exist
        if(os.path.exists(Path)):
            if(os.path.exists(Path)):
                print("[INFO] Load model from disk...")
                self.Model = load_model(Path)
            else:
                print("[ERROR] Unknown input path!")
                return ErrorCodes.UNKNOWN_PATH
        else:
            print("[ERROR] Unknown input path!")
            return ErrorCodes.UNKNOWN_PATH

        return ErrorCodes.NO_ERROR

    def SaveModel(self, Path):
        # Check if the model and the path exist
        if(self.Model != 0):
            if(os.path.exists(Path)):
                print("[INFO] Save model as " + Path + " to disk...")
                self.Model.save(Path)
            else:
                print("[ERROR] Unknown input path!")
                return ErrorCodes.UNKNOWN_PATH
        else:
            print("[ERROR] No model available!")
            return ErrorCodes.UNKNOWN_PATH

        return ErrorCodes.NO_ERROR

    def LoadTrainingData(self, InputPath, OutputPath, SplitRatio = 0.25, RandomState = 0):
        # Preprocess the input images
        self.ImageProcessor.PreprocessAndSaveImages(InputPath, OutputPath)

        # Check if path exist
        if(not(os.path.exists(InputPath))):
            # Check if path is a directory
            if(not(os.path.isdir(Path))):
                print("[ERROR] Unknown input path!")
                return ErrorCodes.UNKNOWN_PATH

        # Load the files from path
        Folder = os.listdir(OutputPath)
        
        print("[INFO] Found {} folder".format(len(Folder)))

        for [FolderIndex, FolderName] in enumerate(Folder):
            # Some status message
            print(" [STATUS] Open folder {}/{}".format(FolderIndex + 1, len(Folder)))

            # Get all the files from the chosen folder
            Files_Folder = os.listdir(OutputPath + "\\" + FolderName)

            for [FileIndex, FileName] in enumerate(Files_Folder):
                # Another status message
                print("     [STATUS] Load file {}/{}".format(FileIndex + 1, len(FileName)))

                # Load a image
                Image = cv2.imread(OutputPath + "\\" + FolderName + "\\" + FileName, 0)

                # Convert it to an array for the neural network
                Image = img_to_array(Image)
                self.TrainingData.append(Image)
            
                # Store the image labels
                self.TrainingLabel.append(FolderName)

        # Count the different labels
        self.Labelcount = len(set(self.TrainingLabel))

        # Skale the data
        print("[INFO] Scale images...")
        self.TrainingData = numpy.array(self.TrainingData, dtype = "float") / 255.0

        # Split the data into training and test data
        print("[INFO] Split data...")
        (self.TrainX, self.TestX, self.TrainY, self.TestY) = train_test_split(self.TrainingData, self.TrainingLabel, test_size = SplitRatio, random_state = RandomState)

        # Preprocess the labels
        print("[INFO] Found {} label".format(self.Labelcount))
        print("[INFO] Convert label...")
        self.Binarizer = LabelBinarizer().fit(self.TrainingLabel)
        self.TrainY = self.Binarizer.transform(self.TrainY)
        self.TestY = self.Binarizer.transform(self.TestY)

        return ErrorCodes.NO_ERROR

    def TrainModel(self):
        # Check if training data are available
        if((not(len(self.TrainX) == 0)) and (not(len(self.TrainY) == 0))):
            print("[INFO] Build LeNet...")
            self.Model = self.LeNet.build(self.Width, self.Height, self.Depth, self.Labelcount)
            self.Model.compile(loss = "categorical_crossentropy", optimizer = SGD(lr = 0.01), metrics = ["accuracy"])

            print("[INFO] Train network...")
            self.History = self.Model.fit(self.TrainX, self.TrainY, validation_data = (self.TestX, self.TestY), batch_size = self.Batchsize, epochs = self.Epochs, verbose = 1)

            print("[INFO] Evaluate network...")
            predictions = self.Model.predict(self.TestX, batch_size = self.Batchsize)
            print(classification_report(self.TestY.argmax(axis = 1), predictions.argmax(axis = 1), target_names = self.Binarizer.classes_))
        else:
            print("[ERROR] No data loaded!")
            return ErrorCodes.NO_DATA

        return ErrorCodes.NO_ERROR

    def Predict(self, InputImage):
        Predictions = []

        # Load image and find all contours
        [BinaryImage, Contours] = self.ImageProcessor.PreprocessImage(InputImage)

        for Contour in Contours:
            # Extract each contour
            (x, y, w, h) = cv2.boundingRect(Contour)
            ROI = BinaryImage[y:y + h, x:x + w]
            ROI = cv2.resize(ROI, (self.Width, self.Height))
            
            # Convert the image to an array and normalize it
            Data = numpy.expand_dims(img_to_array(ROI), axis = 0) / 255.0

            # Create a new prediction
            Prediction = self.Model.predict(Data, self.Batchsize)

            # Print prediction results
            print("Prediction: {}".format(Prediction.argmax(axis = 1)))
            print("Label: {}".format(self.Binarizer.classes_[Prediction.argmax(axis = 1)]))
            
            cv2.imshow("Preview", ROI)
            cv2.waitKey(0)

        return ErrorCodes.NO_ERROR
            