import os
import cv2
import numpy
from keras.optimizers import SGD
from keras.utils import plot_model
from keras.models import load_model
from keras.preprocessing.image import img_to_array
from sklearn.preprocessing import LabelBinarizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt
import pydot

from .LeNet import LeNet
from .ErrorCodes import ErrorCodes

class CaptchaSolver(ErrorCodes):     

    def __init__(self, Width, Height, Depth, Epochs):
        self.Network = LeNet()
        self.TrainingData = []
        self.TrainingLabel = []
        self.TrainX = []
        self.TrainY = []
        self.TestX = []
        self.TestY = []
        self.LeNet = LeNet()
        self.Model = 0
        self.Binarizer = 0
        self.History = 0
        self.Labelcount = 0
        self.Width = Width
        self.Height = Height
        self.Depth = Depth
        self.Epochs = Epochs
        self.Batchsize = 32

    def PrintModel(self, Path):
        if(self.Model != 0):
            print("[INFO] Save visualization to " + Path + "...")
            plot_model(self.Model, to_file = Path,show_shapes = True)
        else:
            print("[ERROR] No model available!")
            return ErrorCodes.NO_MODEL

        return ErrorCodes.NO_ERROR

    def Plot(self):
        if(not(self.History == 0)):
            plt.style.use("ggplot")
            plt.figure(num = "Training")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["loss"], label = "Train (Loss)")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["val_loss"], label = "Test (Loss)")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["acc"], label = "Accuracy")
            plt.plot(numpy.arange(0, self.Epochs), self.History.history["val_acc"], label = "Test (Accuracy)")
            plt.title("Loss and Accuracy")
            plt.xlabel("Epoch #")
            plt.ylabel("Loss/Accuracy")
            plt.legend()
            plt.show()
        else:
            print("[ERROR] No history available!")
            return ErrorCodes.NO_MODEL
        
        return ErrorCodes.NO_ERROR

    def LoadModel(self, Path):
        # Check if path exist
        if(os.path.exists(Path)):
            if(os.path.exists(Path)):
                print("[INFO] Load model from disk...")
                self.Model = load_model(Path)
            else:
                print("[ERROR] Unknown input path!")
                return ErrorCodes.UNKNOWN_PATH
        else:
            print("[ERROR] Unknown input path!")
            return ErrorCodes.UNKNOWN_PATH

        return ErrorCodes.NO_ERROR

    def SaveModel(self, Path):
        # Check if the model and the path exist
        if(self.Model != 0):
            if(os.path.exists(Path)):
                print("[INFO] Save model as " + Path + " to disk...")
                self.Model.save(Path)
            else:
                print("[ERROR] Unknown input path!")
                return ErrorCodes.UNKNOWN_PATH
        else:
            print("[ERROR] No model available!")
            return ErrorCodes.UNKNOWN_PATH

        return ErrorCodes.NO_ERROR

    def LoadTrainingData(self, Path, SplitRatio = 0.25):
        # Check if path exist
        if(not(os.path.exists(Path))):
            # Check if path is a directory
            if(not(os.path.isdir(Path))):
                print("[ERROR] Unknown input path!")
                return ErrorCodes.UNKNOWN_PATH

        # Load the files from path
        Folder = os.listdir(Path)
        
        print("[INFO] Found {} folder".format(len(Folder)))

        for [FolderIndex, FolderName] in enumerate(Folder):
            # Some status message
            print(" [STATUS] Open folder {}/{}".format(FolderIndex + 1, len(Folder)))

            # Get all the files from the chosen folder
            Files_Folder = os.listdir(Path + "\\" + FolderName)

            for [FileIndex, FileName] in enumerate(Files_Folder):
                # Another status message
                print("     [STATUS] Load file {}/{}".format(FileIndex + 1, len(FileName)))

                # Load a image
                Image = cv2.imread(Path + "\\" + FolderName + "\\" + FileName, 0)

                # Convert it to an array for the neural network
                Image = img_to_array(Image)
                self.TrainingData.append(Image)
            
                # Store the image labels
                self.TrainingLabel.append(FolderName)

        # Count the different labels
        self.Labelcount = len(set(self.TrainingLabel))

        # Skale the data
        print("[INFO] Scale images...")
        self.TrainingData = numpy.array(self.TrainingData, dtype = "float") / 255.0

        # Split the data into training and test data
        print("[INFO] Split data...")
        (self.TrainX, self.TestX, self.TrainY, self.TestY) = train_test_split(self.TrainingData, self.TrainingLabel, test_size = SplitRatio)

        # Preprocess the labels
        print("[INFO] Found {} label".format(self.Labelcount))
        print("[INFO] Convert label...")
        self.Binarizer = LabelBinarizer().fit(self.TrainingLabel)
        self.TrainY = self.Binarizer.transform(self.TrainY)
        self.TestY = self.Binarizer.transform(self.TestY)

        return ErrorCodes.NO_ERROR

    def TrainModel(self):
        # Check if training data are available
        if((not(len(self.TrainX) == 0)) and (not(len(self.TrainY) == 0))):
            print("[INFO] Build LeNet...")
            self.Model = self.LeNet.build(self.Width, self.Height, self.Depth, self.Labelcount)
            self.Model.compile(loss = "categorical_crossentropy", optimizer = SGD(lr = 0.01), metrics = ["accuracy"])

            print("[INFO] Train network...")
            self.History = self.Model.fit(self.TrainX, self.TrainY, validation_data = (self.TestX, self.TestY), batch_size = self.Batchsize, epochs = self.Epochs, verbose = 1)

            print("[INFO] Evaluate network...")
            predictions = self.Model.predict(self.TestX, batch_size = 32)
            print(classification_report(self.TestY.argmax(axis=1), predictions.argmax(axis=1), target_names=self.Binarizer.classes_))
        else:
            print("[ERROR] No data loaded!")
            return ErrorCodes.NO_DATA

        return ErrorCodes.NO_ERROR

    def Predict(self, Data):
        # Check if the image exist
        if(len(Data) == 0):
            return ErrorCodes.NO_IMAGE

        # Resize the image to pass it into the cnn
        Data = cv2.resize(Data, (self.Width, self.Height))

        # Convert the image for the cnn to an array 
        Data = img_to_array(Data)

        # Create a new prediction
        return self.Model.predict(Data, self.Batchsize).argmax(axis = 1)
            